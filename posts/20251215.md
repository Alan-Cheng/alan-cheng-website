---
title: 刷題紀錄 - N-Queens
cat: LeetCode
---

今天突然心血來潮想看《鐵達尼號 Titanic》，明明是大熱門電影但卻從來沒看過。 

李奧納多皮卡丘真D帥。

![鐵達尼號 Titanic](https://upload.wikimedia.org/wikipedia/zh/d/d0/TITANIC.jpg)

- **難度**: Hard
- **題目連結**: https://leetcode.com/problems/n-queens

---

### 思考過程

1. N-Queens 是一道很經典的演算法題目，記得當初在研究所補習班的資料結構與演算法課程就有教過，但全部都還回去了，示意圖：

![N-Queens](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

2. 雖然知道要用回溯演算法來做，但是知道方法跟寫成程式碼是兩回事。萬般無奈之下只好求助於 GPT 

3. 由於規則是在一個 n x n 的棋盤中，不可以在同一行、同一列、同對角線中放置 Queen，要怎麼計算對角線就成了第一個難關

4. 這其實可以由公式來定義，同一個主對角線（從左下到右上）的元素，取其座標（row, col） 相減之後可得 diag（diagonal）唯一識別的值。 在同一對角線的元素其 diag 會相同。
    ```
    ➘ diag1 (正對角線) = row - col 
    ➚ diag2 (副對角線) = row + col 
    ```
5. 有了這個就能定義規則，再來就是要想辦法完成回溯（Backtrack）演算法
6. 詳細請看 Python 解法：

### 複雜度分析

- **時間複雜度**：
> 演算法中對每個 row 逐一排列，第一次有 n 個選擇，再來是 n-1、 n-2 ... ，是 n 階層排列。所以是 $O(n!)$


- **空間複雜度**：
> 主要是 board ( List[ List[str] ] )紀錄使用了 $O(n^2)$

---

## 程式碼（Python 解法）
```python
from typing import List

class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []

        """
        規則是通一行、同一列、斜角不能有 Q
        透過宣告一些集合類型的變數來紀錄，集合裡面不能出現重複的元素
        cols:   行
        diag1:  主斜線（左上到右下），可用 row - col 來判斷是否位於同一條主斜線上
        diag2:  副斜線（左下到右上），同上但是用 row + col

        board: 用來紀錄棋盤的狀況

        row 不用宣告，因為我們會逐一配置每一列的 Q 當作過程
        """
        cols = set()
        diag1 = set()
        diag2 = set()

        board = [["."] * n for _ in range(n)]

        # 定義回溯方法
        def backtrack(row: int):
            # 若每個 row 都已經找過，把目前棋盤的結果紀錄到 res 內
            if row == n:
                res.append(["".join(r) for r in board])
                return
            
            # 正式的回溯方法在這，針對每個 row 嘗試放 Q 到每一個 col
            for col in range(n):
                # 若違反規則就不放 Q
                if col in cols or \
                   row - col in diag1 or \
                   row + col in diag2:
                    continue
                
                # 若合法就放進去並記錄下來
                board[row][col] = "Q"
                cols.add(col)
                diag1.add(row - col)
                diag2.add(row + col)

                # 此 row 處理完畢， 進入下一個
                # 這邊會往執行深度深的地方一直下去
                backtrack(row + 1)

                # 結束上面的邏輯就回溯
                board[row][col] = "."
                cols.remove(col)
                diag1.remove(row - col)
                diag2.remove(row + col)
            
        # 調用 backtrack，從 row = 0 開始
        backtrack(0)

        return res
```

---

## 小結 & 反思

- 這題的邏輯不難，難在如何找出對角線與回溯演算法的設計。 結合了類似 DFS 與 遞回，太神奇了。

---