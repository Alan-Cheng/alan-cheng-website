---
title: 刷題紀錄 - House Robber
cat: LeetCode
---

公司外的行道樹全部染成金黃色，從 12F 能一眼望盡敦化南路、文湖線跟整片樹海。好奇查了下是什麼樹，才知道這段是號稱台北最美「欒樹大道」。

工作之餘也要盡情欣賞生活周遭的風景。 隨手拍一下趕快要繼續射飛鏢了。

![](/posts-images/20251218/20251218.png)

- **難度**: Medium

- **題目連結**: https://leetcode.com/problems/house-robber

---

### 思考過程

1. 又是一題 DP。你是闖空門大師，一排房子有不同價值的財產可偷，但你不能偷相鄰的房子否則會被抓

2. 財產用 nums 表示： nums = [2,7,9,3,1] ， 因此最好的偷竊路線就是 2 + 9 + 1 = 12

3. 那就來 DP 一下。從左偷到右，每步都紀錄到目前位置能偷到的最大金額，不斷往後推論就可以得到解答。 目前能偷到最多的金額就是上上家之前能偷到的金額

4. 例如：
```
初始化 dp = [2, 7] <- 前兩家只能這樣，因為都不能偷前面的（別忘了不能偷相鄰的）


nums = [2, 7, (9), 3, 1]
dp = [2, 7, (2+9=11)]

nums = [2, 7, 9, (3), 1]
dp = [2, 7, 11, (7+3=10)]

nums = [2, 7, 9, 3, (1)]
dp = [2, 7, 11, 10, (11+1=12)]

```

5. 取出 dp 中的最大值就是解了

### 複雜度分析

- **時間複雜度**：
> 恩......若 max() 這個方法是 $O(n)$，那整體就會變成 $O(n^2)$

- **空間複雜度**：
> 用了跟 nums 一樣長的 Array，所以是 $O(n)$

---

## 程式碼（Python 解法）
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        dp = [nums[0], nums[1]]

        for i in range(2, len(nums)):
            pass_max = max(dp[:i-1])
            now = nums[i]
            dp.append(pass_max + now)

        return max(dp)
```

---

## 小結 & 反思

- 把我的解法貼給 GPT 看，他說我的解法是錯誤的！出現了以下神奇的對話：

    ![](/posts-images/20251218/20251218-2.png)

    搞笑，結果怎麼測都還是對的？？ 有人能提供我的版本會失敗的測資嗎 =_=



- 但是他的確提出了更好的解法，時間複雜度變 $O(n)$ 之外，空間複雜度也變成 $O(1)$ 了：
    ```python
    class Solution:
    def rob(self, nums: List[int]) -> int:
        prev2 = 0  # dp[i-2]
        prev1 = 0  # dp[i-1]

        for n in nums:
            curr = max(prev1, prev2 + n)
            prev2 = prev1
            prev1 = curr

        return prev1
    ```

---