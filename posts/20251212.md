---
title: 刷題紀錄 - Min Cost Climbing Stairs
cat: LeetCode
---

- 這週只上三天班，又來到歡樂星期五，It's Friday！那就簡單刷一題 Easy 的。
- 好想吃 Friday 的烤豬肋排。

![](https://media1.tenor.com/m/oc4Mn7T3u4wAAAAC/friday.gif)

- **難度**：Easy
- **題目連結**：https://leetcode.com/problems/min-cost-climbing-stairs

---

### 思考過程

1. 給一個 cost = List[int]，每個 index 代表一個開銷，也就是走到那個 index 要支付的成本。 題目要求以最低的成本走到 index = len(cost)，list index out of range 了啦！
2. 題目歸類於 DP-1D（一維動態程式規劃）， 把大問題拆成小問題、並且把小問題的答案記起來避免重複計算的解題方法
3. 也就是走到每個 index 都參考前面的紀錄，目前這階等於前面的最低開銷加上目前的開銷

### 複雜度分析

- **時間複雜度**：
> for 跑了一圈，因此時間複雜度為 $O(n)$

- **空間複雜度**：
> 紀錄每個 index 當下的成本，所以是 $O(n)$。

---

## 程式碼（Python 解法）
```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        # 用來紀錄到每個位置的成本
        # 題目說可以從 index0 或 index1 開始
        rec = [cost[0], cost[1]]

        """
        - 以 cost = [10, [15], 20] 為例，rec 最終會變成 [10, 15, 35]，若返回 rec[-1]，會得到 35 的錯誤結論
        - 因爲題目是要走到頂，也就是 index = len(cost)
        - 所以要找的其實是 cost = [10, 15, 20, (0)] <- 到頂了不用成本，但 rec 要紀錄下來走到這邊最佳的 total_cost
        """
        cost.append(0)
        for i in range(2, len(cost)):
            # 要走到目前這階最低的成本，可能是來自前面一階或是前面兩階累加上來
            step_cost = cost[i] + min(rec[i - 1], rec[i - 2])
            rec.append(step_cost)
        
        return rec[-1]
```

---

## 小結 & 反思

- Easy 的題目果然很簡單，但是 GPT 給出了更好的解法，將空間複雜度降為 **$O(1)$**，還得是你啊：
```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        cost.append(0)  # 到頂不用錢

        dp1, dp2 = cost[0], cost[1]  # 到前兩階的成本

        for i in range(2, len(cost)):
            dp1, dp2 = dp2, cost[i] + min(dp1, dp2)

        return dp2
```

---