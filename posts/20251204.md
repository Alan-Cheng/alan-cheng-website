---
title: 刷題紀錄 - Group Anagrams
date: 2025-12-04
cat: LeetCode
---

- **難度**：Medium  
- **題目連結**：https://leetcode.com/problems/group-anagrams

---

### 思考過程

1. 給一串 List[str]，例如 strs = ["eat","tea","tan","ate","nat","bat"]
2. 每個單字若使用的字母是相同的，那就弄成一組，例如 [["bat"],["nat","tan"],["ate","eat","tea"]]
3. 如果每個單字都按照字母大小排序(eat -> aet，tae -> aet)變成key，那就可以找到每個應該放在一組的單字(s)
4. 用一個 dict 來記錄，dict{key:List[s1, s2...]}
5. 最後把所有 List[s1, ...] 都加入輸出[]，變成[ List[s1, ...], List[s4, ...] ]

### 複雜度分析

- **時間複雜度**：
> * strs 長度為 n ，且每次都要對 s 排序(長度 k)，所以需要 $O(k \log k)$
> * 執行迴圈 n 次
>    >
> 因此時間複雜度為　$O(n k \log k)$
- **空間複雜度**：
> n個單字，每個長度為k，都存於 table 內，因此為 $O(n k)$

---

## 程式碼（Python 解法）

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        table = dict()

        for s in strs:
            # 對 str 用　sorted() 輸出會是排序後的["a", "e", "t"]，因此用 join 組回 str
            key = "".join(sorted(s))
            if key not in table:
                table[key] = []
            table[key].append(s)
        
        output = []
        for key, value in table.items():
            output.append(value)
        
        return output
```

---

## 小結 & 反思

- **有更優解的方法，可將時間複雜度降為　$O(n k \log k)$ ！**
- 用字母頻率 tuple 做 key：
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        table = {}

        for s in strs:
            # 建立 26 個字母出現次數的 tuple
            count = [0] * 26
            for ch in s:
                count[ord(ch) - ord('a')] += 1
            
            key = tuple(count)
            if key not in table:
                table[key] = []
            table[key].append(s)

        return list(table.values())
```

---