---
title: 刷題紀錄 - Find K Pairs with Smallest Sums
cat: LeetCode
---

廢話時間：

星期三固定要進公司，下午開完會就是 Happy 的飛鏢時間。

這週的飛鏢大師是高級工程師 Leo哥。（一開始他沒這麼強啊WTF？） 嚴重懷疑他平常有在偷練，難怪最近寫的 Code 變少了。 

開玩笑的，應該沒有，應該。

![射飛鏢](/posts-images/20251217/20251217.jpeg)

- **難度**: Medium

- **題目連結**: https://leetcode.com/problems/find-k-pairs-with-smallest-sums

---

### 思考過程

1. 題目給兩個存整數且排序的陣列，要求你找出兩個陣列各取一個組成的組合中，最小的 k 個組合。

2. 例如： nums1 = [1, 3, 5]、 nums2 = [4, 5, 6]，k = 2， 那答案就是[[1, 4], [1, 5]] 

2. 老樣子，看到題目一樣直接暴力解。 沒意外會喜提 TLE。

3. 暴力解：
    ```python
    all_pairs = []

    for i in range(len(nums1)):
        cnt = 0
        for j in range(len(nums2)):
            # 因為只找 k 個，固定其中一個的時候，另一個越後面一定越大，所以不用找超過 k
            if cnt == k:
                break
            all_pairs.append([nums1[i], nums2[j]])
            cnt += 1

    all_pairs.sort(key=lambda x: x[0] + x[1])

    return all_pairs[:k]
    ```

4. 結果是得到 MLE = =.....，想也知道這麼簡單就不用做了。

5. 題目歸類在 heap(堆積)，但已經完全忘記 heap 的用法跟結構了，稍微複習一下整理出幾個重點，一些定義自己查 wiki：
    - heap 是完全二元樹
    - heap 可以做 min-heap 或 max-heap
    - 誒？ 突然想到 heap sort
    - 常見操作有，heapify、push 跟 pop，邏輯跟時間複雜度很重要，可以查一下複習
    - python 有 heapq 可以 import ，不用自己實作相關邏輯

6. 好的，知道了這題可以用 min-heap，但是怎做呢？

7. 回到前面的思想： 若固定其中一個 index i = 0 (nums[0]) ， 另一個 index j 越大則組合會越大。

8. 這樣就會得到多個由小排到大的已排序陣列

9. 視覺化一下：
```
[ [0][0], [0][1] ...... [0][j] ]   
[ [1][0], [1][1] ...... [1][j] ]   ← 若比較同 column 的值，越上面的越小 
.
.
[ [i][0], [i][1] ...... [i][j] ]   
   ↑
每 row 最小的都在開頭
```

11. 接下來就是要用 heap 的神奇結構了，先把所有 [i][0] 的值放進 heap，接著就不斷 pop 取出最小值，塞進 pop 出來的那 row 的下一個替補(j 往右移動)


### 複雜度分析

- **時間複雜度**：
> $O(nlogn)$


- **空間複雜度**：
> 因為解法中初始化 Heap 用 
    ```python
    for i in range(min(k, len(nums1))):
    ```
    空間複雜度為 $O(k)$

---

## 程式碼（Python 解法）
```python
import heapq
from typing import List

class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2 or k == 0:
            return []

        heap = []
        res = []

        # 初始化：固定 nums1[0..k-1]，沿 nums2[0] 推
        for i in range(min(k, len(nums1))):
            # tuple 結構： (sum, nums1 index(i), nums2 index(固定為0))
            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))

        # 每次取最小
        while heap and len(res) < k:
            _, i, j = heapq.heappop(heap)
            res.append([nums1[i], nums2[j]])

            # 沿 nums2 向右推
            if j + 1 < len(nums2):
                heapq.heappush(
                    heap,
                    (nums1[i] + nums2[j + 1], i, j + 1)
                )

        return res
```

---

## 小結 & 反思

- Heap 是很重要的資料結構，目前雖然用 heapq 不用自己實作堆積操作，但還是建議複習並自己實作看看。 其中重要的 heapify、push 的 bubble up 等，都要好好複習。

---