---
title: 刷題紀錄 - Maximum Number of Vowels in a Substring of Given Length
date: 2025-12-03
cat: LeetCode
---

- **難度**：Medium  
- **題目連結**：https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length

---

### 思考過程

1. Vowel letters：母音字母 A、Ｅ、Ｉ、Ｏ、Ｕ
2. 要找出一個字串中，大小為 k 子字串之中含有最多的母音字母的數量
3. 用看看大小為 k 的滑動視窗法
4. 第一次寫的版本時間複雜度太高導致 TLE，for 迴圈跑 n 次，而每次都檢查長度大小為 k 的陣列
5. 因此第一次版本的時間複雜度為 $O(n * k)$ ：
```python
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        # 紀錄字母數量跟母音字母有哪些
        output = 0
        vowels = {'a', 'e', 'i', 'o', 'u'}

        # 滑動視窗
        for i in range(len(s) - k + 1):
            window = s[i:i+k]
            count = sum(1 for c in window if c in vowels)
            output = max(output, count)
        return output
            
```
6. 滑動視窗法不應該每次重新計算視窗內的狀態，而是更新就好！
7. [**[1,2]**,3,4,5] -> 視窗往右邊移 -> [1,**[2,3]**,4,5] (1滑出，3滑進)
 -> ⋯⋯ 
8. 每次只要在滑進與滑出的元素上調整狀態就好，邏輯就寫在這
9. 重要邏輯重構：
```python
# 初始化前 k 個字母（ 滑動視窗在初始位置 [[a,b],c,d,e] , k = 2）
for i in range(k):
    if s[i] in vowels:
        count += 1
max_count = count

# 滑動視窗：進一個字母、出一個字母（ [a,[b,c],d,e] , k = 2）
for i in range(k, len(s)):
    if s[i] in vowels:      # 新進來的是母音，加一
        count += 1
    if s[i-k] in vowels:    # 滑出的是母音，減一
        count -= 1
    max_count = max(max_count, count)
```

### 複雜度分析

- **時間複雜度**：$O(n)$，只遍歷 s 一次。
- **空間複雜度**：$O(1)$，只儲存固定數量的變數。

---

## 程式碼（Python 解法）

```python
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        count = 0
        max_count = 0

        for i in range(k):
            if s[i] in vowels:
                count += 1
        max_count = count

        for i in range(k, len(s)):
            if s[i] in vowels:   
                count += 1
            if s[i-k] in vowels:
                count -= 1
            max_count = max(max_count, count)

        return max_count
```

---

## 小結 & 反思

- 滑動視窗法的精髓不是每次移動固定大小的 sub array 並重新計算內部狀態
- **精髓在於每次透過進出的元素來更新狀態！！** 

---