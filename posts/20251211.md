---
title: 刷題紀錄 - Delete Node in a BST
cat: LeetCode
---

- 上午把自己開發的功能上線。 沒想到在生產環境直接炸了。 兩個維運工程師陪我搞了一整個上午，快到十二點的時候超過系統上線時間，直接 rollback = 做了半天白工。


![](https://media1.tenor.com/m/GiUbb4qg_vwAAAAC/csharp-cat-programmer.gif)

- **難度**：Medium  
- **題目連結**：https://leetcode.com/problems/delete-node-in-a-bst

---

### 思考過程

1. 這題是二元搜尋樹(BST)的經典題目，給一個 key 叫你刪掉那個節點
2. 問題在刪掉一個節點，樹還要保持 BST 的結構。好像有標準作法，但是完全忘記了只好直接問GPT
3. **其實做法很簡單，如果要刪的是葉那就直接刪，否則就是找一個節點來補到被刪掉的位置就好**
4. OK, 那怎麼找節點來補最快？ 那就是找個葉節點來補，且又要符合 BST 左小右大的結構
5. 解法就是從要被刪的節點的左子節點再往最右邊一直找，或是右子節點往最左邊一直找，那就會剛好找到 **一個可以補上的葉節點，且補上後還是符合左小右大的結構**
    - 這邊邏輯有個錯誤，這個方法找到的不一定是葉節點⋯⋯
6. 以右子節點為例，右子節點比父節點大，但是一直往左邊找就會找到比父節點大但是比右子節點小的葉節點
7. 左邊同理，會找到小於但相對整顆左子樹最大的葉節點
8. 接下來就是實作了！
9. 一開始這樣做，但是問題可大了
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        
        if not root:
            return root
        
        # 開始找要刪除的節點在哪
        # par 用來記錄要刪掉的節點的父節點，以便後面接回來
        # cur 用來找要刪掉的節點
        par = TreeNode(0)
        cur = root
        while cur and cur.val != key:
            if key > cur.val:
                par = cur
                cur = cur.right
            else:
                par = cur
                cur = cur.left
        
        # while 迴圈結束，代表找到要刪除的節點，或是都沒找到
        # 沒找到就返回 root
        if not cur:
            return root
        # 找到就進行處理，從cur的右子節點往最左邊找到替補的節點
        else:
            # 前面有用 par 紀錄了刪除節點斷掉的地方
            # 現在要紀錄下左右兩邊，方便等等接回來
            left = cur.left
            right = cur.right
            padding = cur.right
            # 一直往 padding 左邊開始找 
            # 用個前導的指標來找
            nxt = padding
            while nxt:
                padding = nxt
                nxt = nxt.left
            
            # while 迴圈結束後，padding 就是要拿來填充的節點
            # 判斷一下 padding 比 par 的 val 大還小，就可以判斷要接左邊還右邊
            if par.val > padding.val:
                par.left = padding
            else:
                par.right = padding

            # 把左跟右接上去
            padding.left = left
            padding.right = right

            return root
```
10. 經過 GPT 修正，指出了非常多錯誤：
    - 原本的寫法沒有考慮到 **可能沒有右子樹只有左子樹**，即 Case 1 的部分。
    - padding 找法錯誤，padding 指到最左節點是對的，但遺失了它的父節點，會造成後面無法把 padding 從原本位置拔除。
    - 要刪除的是根節點的時候會失敗，因為 root 根本沒有 par
    - padding 時沒有把 cur 拔除，也沒有把padding拔除
    - padding 本身可能有右子樹，必須把 padding.right 接回原本 padding 的位置，否則 C 節點就會丟失：
        ```
            cur
            /   \
        left   right
                / \
            padding B
                \
                C
        ```
11. GPT 給的修正版本：
```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:

        if not root:
            return root
        
        par = None
        cur = root

        # 找要刪除的節點
        while cur and cur.val != key:
            par = cur
            if key > cur.val:
                cur = cur.right
            else:
                cur = cur.left
        
        if not cur:
            return root  # 沒找到
        
        # Case 1: 只有一邊子樹或沒有子樹
        def replace_child(parent, old_child, new_child):
            """把 parent 的 old_child 替換成 new_child."""
            if not parent:
                return new_child  # root case
            if parent.left is old_child:
                parent.left = new_child
            else:
                parent.right = new_child
            return root

        if not cur.left:
            return replace_child(par, cur, cur.right)
        if not cur.right:
            return replace_child(par, cur, cur.left)

        # Case 2: 兩邊都有 → 找右子樹最左邊
        succ_par = cur
        succ = cur.right
        while succ.left:
            succ_par = succ
            succ = succ.left
        
        # succ 是 successor，把它的值複製過來
        cur.val = succ.val

        # 把 successor 從原本位置拔掉
        if succ_par.left is succ:
            succ_par.left = succ.right
        else:
            succ_par.right = succ.right

        return root
```

### 複雜度分析

- **時間複雜度**：
> 操作最差需要找到跟樹高一樣多的節點，然後每次刪除跟搬動的操作都是常數，所以平均是 $O(logn)$，最差的狀況不平衡的樹那就是 $O(n)$
- **空間複雜度**：
> 使用固定數量的指標，所以是 $O(1)$。

---

## 程式碼（Python 解法）
- GPT 給出建議，可以用遞回的方法來解這題：
```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root:
            return None
        
        # 找到要刪除的節點
        if key < root.val:
            root.left = self.deleteNode(root.left, key)
        elif key > root.val:
            root.right = self.deleteNode(root.right, key)
        else:
            # 找到節點 root.val == key

            # Case 1: 沒有左子樹
            if not root.left:
                return root.right
            # Case 2: 沒有右子樹
            elif not root.right:
                return root.left
            # Case 3: 左右子樹都存在 → 找右子樹最左節點 (successor)
            else:
                succ = root.right
                while succ.left:
                    succ = succ.left
                # 將 successor 的值複製到 root
                root.val = succ.val
                # 刪掉右子樹的 successor 節點
                root.right = self.deleteNode(root.right, succ.val)
        
        return root
```

---

## 小結 & 反思

- **遞迴的方法漂亮多了，以邏輯來說沒有一步一步來那麼直覺，但是漂亮的方法就是賞心悅目啊......**

---