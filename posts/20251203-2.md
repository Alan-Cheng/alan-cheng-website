---
title: 刷題紀錄 - Max Number of K-Sum Pairs
date: 2025-12-03
cat: LeetCode
---

- **難度**：Medium  
- **題目連結**：https://leetcode.com/problems/max-number-of-k-sum-pairs

---

### 思考過程

1. 給個目標 k，從 nums: List[int] 中不斷挑出並移除兩個數字加起來剛好等於 k，最後輸出有幾種組合。
2. 先把 nums 從小到大排序，用指標從最左邊(l)跟最右邊(r)往中間掃。
    - 若 k = 4 , [**[1]**,2,3,4,**[5]**] 目前sum = 6 ( nums[l] + nums[r] )
    - 6 > 4，右邊的比較大，所以 r 往中間靠
    - [**[1]**,2,3,**[4]**,5] -> 重複步驟
    - [**[1]**,2,**[3]**,4,5] -> sun = 4
    - 移除 1 跟 3，l 跟 r 往中間移動一格
    - [2,**[[4]]**,5]，若重疊或是 nums 為空就結束
3. 實作後發現題目沒看清楚，根本不用移除發現的組合。輸出只要組合數，移除元素反而造成 index 難以計算
4. 那就修改一下，不用移除元素的話更簡單了

### 複雜度分析

- **時間複雜度**：因為用到排序，所以時間複雜度 $O(n \log n)$
- **空間複雜度**：不確定排序使用到的空間，但是以自己寫的部分來說是 $O(1)$

---

## 程式碼（Python 解法）

```python
class Solution:
    def maxOperations(self, nums: List[int], k: int) -> int:
        # 先排序
        nums.sort()
        l, r = 0, len(nums) - 1
        count = 0

        while l < r:
            s = nums[l] + nums[r]
            if s == k:
                count += 1
                l += 1
                r -= 1
            elif s < k:
                l += 1
            else:
                r -= 1
        return count
```

---

## 小結 & 反思

- 還有另一種用空間換時間的寫法，那就是用 **HashMap** 的方式
- Python 可以簡單地用 Dict 來實作：
```python
class Solution:
    def maxOperations(self, nums: List[int], k: int) -> int:
        # 用一個 map 來紀錄，結構是 {"數字":"出現次數"}
        table = {}

        count = 0
        # 概念是邊掃數字邊找有沒有能配對的補數
        for num in nums:
            diff = k - num
            # 先判斷 num 的補數是否存在，如果補數根本沒紀錄過或是已經用完了
            if diff not in table or table[diff] == 0:
                # 那就把 num 存起來當還沒配對到的數
                if num not in table:
                    table[num] = 0
                table[num] += 1
            else:
                # 找到補數就紀錄下來，並且把補數數量 -1
                count += 1
                table[diff] -= 1
        return count
```
- **因為不需要排序，時間複雜度只有 $O(n)$**，但空間複雜度最差需要 $O(n)$ ，因為可能把所有元素都記錄下來
![天才](/posts-images/20251203/20251203.png)
---