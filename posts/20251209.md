---
title: 刷題紀錄 - Leaf-Similar Trees
cat: LeetCode
---

- 從清邁回來了，明天又是開心當碼農的一天。


![泰國爽](https://pic4.zhimg.com/v2-1a90bf91df75e686dc42d563ec10b439_1440w.gif)

- **難度**：Easy  
- **題目連結**：https://leetcode.com/problems/leaf-similar-trees

---

### 思考過程

1. 這題給了兩棵樹(root1 and root2)，目的是要找兩棵樹的葉是否從左到右相同。
2. 直覺想到用遞迴來解，那就試試看 DFS？
3. 複習一下：DFS 也可以用 Stack 來實作，BFS 可以用 Queue 來實作
4. DFS 過程中只要找到葉子就記錄下來，這樣的話我需要分別存下兩棵樹的葉子序列
5. 兩棵樹各自跑一次 DFS，最後 return 兩個葉子序列的比較結果即可

### 複雜度分析

- **時間複雜度**：
> 兩棵樹都要遍歷每個節點，因此時間複雜度為 $O(n1 + n2)$
- **空間複雜度**：
> - 使用遞回的 DFS 方法，最好的狀況下是平衡樹 $O(logn)$，最差是歪斜樹 $O(n)$。
>
> - **此種樹的遞回方法空間複雜度跟樹的高度有關係，DFS 會不斷往下去挖，搜尋過程會不斷使用儲存空間。**

---

## 程式碼（Python 解法）

```python
class Solution:
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        # 紀錄兩個樹的leaves
        leaves1 = []
        leaves2 = []

        # 定義一個可以找到 leaves 的方法，用 DFS 搜尋
        # DFS只要判斷是葉子就儲存到 leaves 裡
        def dfs(node, leaves):
            if not node:
                return 
            # 若沒有左右子樹，那就是葉並記錄下來
            if not node.left and not node.right:
                leaves.append(node.val)
            # 繼續遞迴搜尋左右子樹
            dfs(node.left, leaves)
            dfs(node.right, leaves)
        
        # 分別去找 root1 跟 root2 
        dfs(root1, leaves1)
        dfs(root2, leaves2)

        return leaves1 == leaves2
```

---

## 小結 & 反思

- 重新複習一下 **遞回** 、 **DFS** 、 **BFS** 比較好 

---